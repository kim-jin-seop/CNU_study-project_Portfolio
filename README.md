# CNU_study-project_Portfolio
충남대학교 대학생활하며 진행한 프로젝트 모음

--------

# 1. TermProject_TravelDiary
## 객체지향설계 TermProject(2017-가을학기)
객체지향 설계 자유주제 Term Project

여행을 가서 일정을 기록하는 다이어리 안드로이드 어플리케이션

----------
# 2. SystemPrograming_Lab
## 시스템 프로그래밍 Lab(2017-가을학기)

## Shell Lab

Signal을 사용하여, 리눅스의 Shell을 구현.

카네기멜론 대학의 shlab

## Malloc Lab

Malloc Lab
for System Programing HomeWork

use next-fit & First-fit

--------

# 3. WebPrograming_Project
## 웹프로그래밍(2018년-봄학기)
## Self-introduction
- HTML, CSS  
- 자기소개 웹페이지

## TodoList_1
- HTML, CSS, java script
- 주간계획을 삽입, 수정, 삭제할 수 있는 TodoList

## TodoList_JSP
- JSP, CSS, java script, html
- TodoList를 jsp로 구현

## FootBall_Matching_System
- JSP, CSS, java script, html
- 충남대학교 풋살매칭 웹페이지 개발

--------

## 4. 2018년도  프로그래밍언어개론
### Recursion_Fibonacci_Ant
- 재귀함수 구현
- 피보나치
- 개미수열(11223 -> 122231 (입력값을 읽음, 1이 2개 2가 2개 3이 1개)

### Recognizing Tokens 
- 다양한 형태의 토큰을 입력받아 토큰의 요소 인식

### Cute14_Scanner
- Cute14문법에 따라 작성된 program을 입력받아, 모든 token을 인식하여 token과 lexeme을 모두 출력

### Node_Max_Sum
- 문자열을 Node로 return하는 JAR파일 활용
- 노드의 종류를 List와 Int만 있다고 가정을 하고, 최대값과 총합을 구하는 메소드 작성

### Cute18_Parser
- Cute18 문법에 따라 작성된 program을 입력받아, 프로그램의 syntax tree를 생성하는 parsing을 수행
- syntaxtree를 root로부터 pre-order traverse로 하여 원래 입력된 프로그램과 구조가 동일한 프로그램을 출력

### Cute18_Parser2
- Cute18 문법 파싱 추가

### Cute18_built_in_Function
- Cute18의 내장되어있는 함수를 구현
- ex) List연산 : car,cdr 등

### Cute18_interprete_1,2,3
- Cute18문법에 따른 프로그램을 입력하면 결과를 출력하는 인터프리터 구현
- 1 : Interpretation환경 구현(Read-Eval-Print Loop)
- 2 : 변수 바인딩처리
- 3 : 함수의 바인딩처리


## 주요 프로젝트
#### Cute18_interprete_1,2,3
--------------------------------------

# 5. TermProject_StoreSystem

## 모바일 프로그래밍 및 설계 TermProject(2018-가을학기)
판매업체와 기업의 재고를 관리하는데 도움을 주는 어플리케이션

### 제품 소개
판매업체와 판매업체에 물품을 공급하는 물품 공급 기업의 재고관리에 도움을 주는 어플리케이션이다.  
판매업체는 판매 제품의 재고를 효율적으로 관리가 가능하도록 어플리케이션으로 판매하는 물품에 대한 정보를 보여준다.  
판매업체는 재고가 일정수준 떨어지게 되면 자동으로 발주할 수 있는 기능이 있어서, 재고의 관리의 효율성을 높일 수 있다.  
### 기능 소개
#### 기업
- 판매업체에게 판매할 물품을 등록, 및 수정  
- 판매업체가 요청한 발주에 대한 처리기능  

#### 판매업체
- 기업에서 등록한 물품을 추가하여 판매 관리 대상으로 등록
- 기업에게 발주 요청 가능
- 자동으로 발주할 수 있도록 설정 가능
- 판매업체가 물품을 판매하면, 포스에서 자동으로 물품량 

## 6. 2018년도 가을학기 컴파일러개론
### Hoo_Compiler
- Hoo 파일을 입력받아, C코드를 출력하는 프로그램
~~~~
/*Hoo코드 예시*/
[abc]: print    // abc 를 출력 
[abc]: ignore   // 아무 것도 안 출력 
[abc]: (3) print    // abcabcabc 를 출력 
[]:print    // 빈 줄 출력 (newline) 
 
[abc]: 
[def]: 
[ghi]: print    // abcdefghi 를 출력 
 
[abcb][e/b]:print   // aece를 출력 (모든 b대신 e로 바꿈) 
[abcb][U]: print    // ABCB를 출력 (모두 대문자) 
[aBCB][L]: print   // abcb를 출력 (모두 소문자) 
 
[abc]: 
[def][e/f]:
[ghi][h/i]: (2) print  // abcdeeghhabcdeeghh를 출력 
~~~~
- Hoo 파일은 문법상의 오류가 없는것으로 가정하고 구현
###  MiniGoPrintListener
 - 'ANTLR'를 활용해 주어진 문법에 대하여 go파일을 pretty print하는 프로그램
 - pretty print 조건
 1. 블록이나 nesting 되어 들어갈 때는 4칸 들여쓰되 ‘.’을 찍음 
 1. If 등의 특수 절이나 함수 시작은 괄호를 함수 옆에 표시한다. 
 1. 2진 연산자와 피연산 사이에는 빈칸을 1칸 둔다. Ex) x+y -> x + y 
 1. 전위 연산자와 피연산자 사이에는 빈칸을 두지 않는다. Ex) ++x  
 1. 일반 괄호는 expression에 붙여 적는다. Ex) (x + y) 

### First_Follow
- first, follow 및 Recursive Descent Parser 구현
- 구문분석방법인 Top-Down방식에서 활용되는 First와 Follow 구현
- Recursive Descent Parser 구현

### UcodeGen_MiniGo
- MiniGo.g4파일에 대한 문법을 바탕으로 Ucode를 생성하는 Compiler 제작
- Go파일을 입력받고, Antlr가 파싱을하여 파싱 결과를 ucode로 변경해주는 Compiler
- 처음으로 만들어본 컴파
### UcodeGen_MiniGo2
- print 문법 추가
## 주요 프로젝트
#### UcodeGen_MiniGo2

------------------------------------------------------------------------

#  7.Algorithm Study
- 충남대학교 컴퓨터공학과 김진섭
- 2018년도 가을학기 알고리즘
---------------------------------------------------------------------  
# SORT 알고리즘
## Insert_Bubble_select_Sort_JAVA  
[알고리즘] 선택정렬, 버블정렬, 삽입정렬 구현  
- 시간복잡도 : O(n^2)
- 삽입정렬 : 모두 정렬되어있는 데이터면 O(n)

## Merge_Quick_Sort_JAVA
[알고리즘] 퀵정렬, 합병정렬 구현  
- 시간복잡도 : O(nlogn)
- Quick Sort : 정렬되어있는 경우 O(n^2)

## Heap_Counting_Sort_JAVA
[알고리즘] Heap Sort, Count Sort
- Heap Sort : O(nlogn)
- Count Sort : O(n) (단, n은 데이터의 값의 크기)
---------------------------------------------------------------------
# Tree 알고리즘  
## [AL]BST
[알고리즘] Binary Search Tree
- 데이터를 삽입할 때 왼쪽으로 작은값 오른쪽으로 큰 값으로 삽입  
- tree의 높이가 낮다면 O(logn)만에 데이터 찾기 가능

## Red_Black_Tree_JAVA  
[알고리즘] Red Black Tree
- BST인데 균형을 맞추기 위하여 노력을 한 Tree
---------------------------------------------------------------------
# Hash table 알고리즘
## Hash_Table_JAVA
[알고리즘] Hash Table
- Linear Hash Table
- Quadratic Hash Table
- Double Hash Table
---------------------------------------------------------------------
# 상호 배타적 집합
## Union_Find_JAVA
[알고리즘] Union Find
- Union : 집합을 결합
- Find : 집합에서 값을 찾음
---------------------------------------------------------------------
# 동적 프로그래밍
## LCS_JAVA
[알고리즘] Longest Common Subsequence

input File
-> data1 Length\ndata1\ndata2 Length\ndata2

output File
-> LCS

알고리즘 과제 수행(동적 프로그래밍)
-	과제 목표 : LCS
LCS는 최장 공통 부분 순서를 의미하며 두 문자열 중 공통 부분이 가장 긴 문자열을 뽑아내는 것이다. 이 때 문자열이 연속적일 필요는 없다.

-	해결 방법 : LCS(동적 프로그래밍)
LCS를 재귀적으로 생각하여 보면, X를 x1x2x3x4…로 이루어진 String이고(xa는 char) Y를 y1y2y3…라 한다고 했을 때, xi와 yj에 대하여 생각해보자. 우선 xi와 yj에서의 최장 길이에 대한 데이터 정보가 담긴 값으로 cij가 있다고 하자. 우리가 유의해 살펴보며 찾아야하는 값은 cij이다.
만약, I 또는 j가 0이있는 경우에는 두 문자열 중 하나가 문자가 아무것도 없는 경우이므로 0을 넣어준다.
만약 xi와 yj가 같은 경우라면 cij는 c(i-1)(j-1)에서 1을 더해준 값이 된다.
만약 두 값이 서로 다른 경우라면, c(i-1)j나 ci(j-1)중에서 큰 값이 들어가게 될 것이다.
위 방법대로 재귀적으로 사용을 하게 되면, 심한 중복 호출이 발생한다. 따라서, 이를 해결하기 위해서는 구해준 cij에 대한 정보를 0에서부터 차례대로 삽입하며 테이블을 형성해야한다.
---------------------------------------------------------------------
# 그래프 알고리즘
## DFS_BFS_JAVA

[알고리즘] 깊이우선탐색과 너비우선탐색 알고리즘 구현
- DFS  
깊이우선 탐색 알고리즘  
- BFS  
너비우선 탐색 알고리즘  

## Prim_Kruskal_JAVA
[알고리즘] 프림과 크루스칼 

## Dijkstra_Bellman-Ford_Java 

[알고리즘] 다익스트라와 벨만포드 알고리즘 구현
- 다익스트라
최단 경로를 찾아내는 알고리즘
음의 간선이 존재하는 경우 다익스트라가 원활히 수행이 안됨

- 벨만포드
최단 경로를 찾아내는 알고리즘
음의 사이클이 존재하는 경우 벨만포드가 원활히 수행이 안됨

---------------------------------

### 8. 2018년 동계 백마인턴쉽

[김진섭 Tstory 블로그](https://cnu-jinseop.tistory.com/)  
uArm을 처음 접해보신 분들은 위 링크에 들어가서 학습해보시길 권장합니다.

## 프로젝트 개요
알파 오목이 서버에서 오목을 두면, 그 정보를 받아서 로봇팔이 바둑돌을 해당 위치에 두는 uArm 개발

## 프로젝트에 사용된 물품
- uArm Swift Pro
- C타입 케이블
- 아두이노 메가보드
- SuctionCup
- 바둑돌 등등

## 프로젝트 
우선, 프로젝트를 진행하기 위해서는 기본적으로 아두이노 스케치와 Xloader라는 프로그램이 필요합니다.
- [아두이노 스케치](https://www.arduino.cc/en/Main/Software)
- [Xloader 다운로드](http://xloader.russemotto.com/)  
설치가 되어있지 않다면 위 링크에 들어가서 설치 하시길 바랍니다.


1) Xloader를 활용하여, uArmSwiftPro_2ndUART.hex를 uArm에 업데이트 시켜줍니다.
2) 아두이노 스케치를 이용하여 Omok 코드를 열어줍니다.
3) 아래 코드의 값들을 각각 세팅해줍니다.
```c
int OmokNum = 0; //오목돌을 몇번째 두는가에 대한 정보
int useX = 104;//X초기값
int useY = -149; //Y초기값
int useDimensionX = 4; //X의 차원
int useDimensionY = 2; //Y의 차원
int use_length = 47; //사용하는 바둑집의 길이

int omok_demention = 9; //바둑판 크기 a*a이면 omok_demention = a
int omok_length = 25; //바둑판 착점의 한칸의 크기
int firstX = 131; //바둑판 최우측하단의 X좌표
int firstY = -95; //바둑판 최우측하단의 Y좌표
```
위 6개의 변수는 바둑돌의 집에 대한 변수이고, 아래 4개의 변수는 바둑판에 대한 변수입니다.

바둑판은 uArm을 기준으로 우측 최 하단 부분의 좌표가 초기 값이 됩니다.  
바둑알 집은 uArm 기준으로 좌측 최 하단 부분의 좌표가 초기값이 됩니다.

4) 세팅이 완료되었다면, 메가보드에 업로드시켜줍니다.
5) 메가보드와 uArm을 연결시켜주면 사용이 가능합니다.


ps) uArmStudio를 사용하기 위해서는, Xloader를 활용해 uArm을 Standard로 업데이트 시켜주어야합니다!


## 9. Data Science
- 충남대학교 2019년도 봄학기 데이터과학   
  
## 과제 
### Tashu
- 대전의 공공자전거 데이터 타슈 데이터
- 기상청 데이터
- 데이터를 활용하여 공공자전거 사용빈도 및 관리 최적화를 위한 분석
   
### Fitness_Traker
- fitbit을 활용하여 얻은 건강데이터 분석
- 제이슨 파일읽기 활용해 데이터 정제

### PageRank  
- 하둡설정 ( 노드 세팅 )
- Word Count 수행

### Movie_Rating  
- 영화 평점 데이터 활용
- 네이버영화 평점에서 크롤링하여 데이터 수집

## PageRank2
- PageRank 알고리즘

# 10.Maze_Escape_Embedded
- 충남대학교 컴퓨터공학과 김진섭
- 2019년도 봄학기 임베디드 소프트웨어
- Embedded Challenge 2등
---------------------------------------------------------------------  
## 대회 소개
- ubrain을 활용하여 랜덤하게 만든 미로의 벽에 부딪히지 않고 통과하는 자율주행 Embedded 구현 대회
- 순위는 빠르게 통과하는 순서로 매김

----------------------------------------------------------------------
## 설계
1. 주행전략  
- 안전성  
(초음파 센서)     
초음파 센서는 ubrain의 좌 우 그리고 앞에 있습니다. 따라서, 초음파 센서를 활용하여 이동하며 전방에 장애물 이 있는지 탐지하고 장애물이 있다면 좌측 혹은 우측으로 방향을 전환하여 장애물을 피해갑니다.     
(IR 센서)  
Calibration을 정확히 해 주어도 바퀴가 틈에 걸리는 경우, uBrain의 배터리의 잔량 등의 예외상황 때문에 정확 히 장애물들을 피해 이동하기가 어렵습니다. 초음파 센서는 ubrain의 전방과 좌 우 방향의 장애물만 탐지가 가 능하기 때문에 대각선 방향으로 점차 가까워지는 경우에 물체 감지를 할 수 없습니다. (대각선 방향으로 가까워 지는 경우는 정확히 90도 회전을 못하거나, 직선으로 이동을 하지 못하는 경우입니다.) 따라서 저희는 좌측 우측 45도 방향에 있는 적외선 센서를 활용하여 1자로 이동을 하지 못하고, 약간 우측 혹은 좌측으로 치우친 이동을 해서 장애물과 부딪히게 되는 것을 방지하기 위하여 적외선 센서를 활용하여 약간의 방향 조정을 해주는 방법으로 구현을 하였습니다.  
- 목표 성취를 위한 주행 전략   
(uBrain의 방위)   
uBrain은 자신이 지금 어디로 움직이고 있는지 인지를 하지 못합니다. 즉 시작을 해서 좌측 90도 돌아서 움직여 도 ‘앞으로 간다’고 생각하지, ‘시작방향의 좌측으로 이동하고 있다.’ 라고 생각하지 않습니다. 따라서 저희는 좌 측 혹은 우측으로 가는 경우를 나누어 uBrain이 지금 어느 방위로 이동을 하고 있는지 판단하도록 구현하였습니 다. uBrain이 시작되는 지점의 전방이 북쪽 후방이 남쪽 우측이 동쪽 좌측이 서쪽으로 판단하여 현재 어느 방향 으로 uBrain이 이동하고 있는지 알도록 구현하여, 상황에 따른 방향 수정을 할 수 있도록 구현하였습니다.  
(주행 전략)  
위에서 언급하였듯이 uBrain이 현재 어느 방향으로 이동하고 있는지(방위)를 알 수 있도록 구현을 하였습니다. 따라서, 방위에 따라 uBrain이 어느 방향으로 회전을 하는 것이 바람직한지를 알 수 있습니다. 저희는 uBrain을 최대한 빨리 완주를 할 수 있도록, 무조건 북쪽으로(목적지)로 갈 수 있도록 알고리즘을 개발하 였습니다. 서쪽으로 동쪽으로 이동을 하는 경우에는 북쪽으로 가능 방향의 초음파 센서를 확인하여 북쪽으로 갈 수 있는 길이 있다면, 무조건 빠르게 그 길을 갈 수 있도록 코드를 구현하였습니다. 즉, 서쪽으로 가는데, 오른쪽 초음파 센서를 확인 결과 북쪽으로 가는 길이 있다면 바로 그 길을 선택하여 이동 을 하고, 동쪽으로 가는데 왼쪽 초음파 센서를 확인 결과 북쪽으로 가는 길이 있다면 그 길을 선택해 이동하는 것입니다. 또한 장애물을 만나 이동을 할 때도 북쪽에 장애물이 없다면 무조건 북쪽으로 회전하여 이동을 하도 록 구현을 하였습니다. 요약을 하면, 저희의 주행 전략은 빠른 목표 도달이었으며, 그 방법을 위해 uBrain의 방위를 주고 그 방위 중 목 표지점이 있는 곳(북쪽)으로 최대한 다가가려고 노력하는 알고리즘을 구현하였습니다.  
(정확한 Calibration)   
Calibration을 정확히 해 주지 못하면 90도로 직각으로 회전을 하지 못하고, 직선방향으로 이동이 어렵습니다. 그렇게 되면 장애물을 만나게되고 장애물을 만나면 IR센서에 의해 약간의 거리를 보정해야하며 그 거리를 보정 하기 위해 잠시 멈추어야하는 상황이 됩니다. 저희의 목표인 ‘최대한 빨리 목표에 도달’을 달성하기 위해서는 이 렇게 보정을 위해 잠시 멈추는 상황을 최대한 적게 할 필요가 있다고 생각하여 정확한 Calibration을 해주려 노 력하였습니다. 정확히 직선방향으로 이동하기 위하여 Palse값을 조절 하였고, 회전되는 회전율도 계속 변경하여 최대한 90도가 될 수 있도록 수 백번 계속 uBrain에 코드를 로드하고 테스트하는 것을 노력하였습니다.  
2. 전략의 우수성  
- 안전성   
저희의 전략은 초음파 센서를 활용하여 전방에 있는 장애물을 감지하고 추가로 적외선 센서를 활용하여 대각의 장애물들이 점차 가까워지는 것을 확인하고 방향 조정으로 부딪히는 것을 방지하여 최대한 안전하게 움직이도 록 노력하였습니다. 요약 – 초음파 센서와 적외선 센서로 장애물을 감지하여 안전을 우선시하는 전략을 구사하였습니다.  
- 최대한 빠르게 목표에 도달하기
저희의 두 번째 전략은 최대한 빨리 목표지점에 도달하기 위해서 ubrain이 해야 하는 노력에 대하여 생각하였습 니다. 따라서, 무조건 벽이 앞에 보이면 고개를 돌리고 가는 것 보다, 목표지점으로 갈 수 있는 길이 있다면 그 곳으로 가는 것으로 약간의 시간 단축을 하려고 노력하였습니다. 두 번째로 항상 방위를 주어 갈림길에 놓여있 는 상황일 때 어디로 가는 것이 빠를지 판단하여 회전을 하도록 만들었습니다. 마지막으로 Calibration을 정확하 게 해 주어 약간 비스듬하게 가서, 적외선 센서에 의해 방향 조정을 하는 시간을 단축시키고자 노력하였습니다. 요약 – 목표지점으로 가는 길이 있다면 그 길을 바로 활용하고, 갈림길에서도 방위를 알고 목표지점을 찾아서 이동하며, Calibration을 최대한 정확히 해서 방향 조정을 최소화하는 전략으로 최대한 빠르게 트랙을 통과하는 전략을 구사하였습니다.  
3. 테스크 구성 및 설계 
- 테스크 구성   
총 두 개의 테스크를 구성하였습니다. 장애물을 탐지하여 방향을 설정하는 테스크, 모터를 제어하는 테 스크 이렇게 두 개의 테스크로 나누어 구성하였습니다. 장애물 탐지 및 방향을 설정하는 테스크에서 장애물을 탐지하면 현재 ubrain의 상황(방위, 장애물 위치)에 따라 움직여야하는 것을 flag로 제시하면 모터 제어 테스크 에서 이를 통해 움직임을 제어하여주는 방식으로 구성하였습니다. 테스크를 두 개만 구성하여 최대한 시스템의 불안전성을 막으려고 노력하였습니다.  
- 장애물 탐지 및 방향 설정 테스크(테스크1)  
장애물을 탐지하고 방향을 설정하는 테스크는 현재 ubrain이 어느 방위로 움직이는지, 주변의 장애물이 어디에 위치하는지에 따라 방향을 제시하게 됩니다. 테스크에 대하여 간단히 설명을 드리도록 하겠습니다. - 장애물이 앞에 있는 경우(초음파 센서로 바로 앞에 장애물이 탐지된 경우) 이 경우에는 왼쪽, 오른쪽 초음파 센서를 활용해 좌우측에 벽이 있는지 감지합니다. 그리고 좌우측에 벽이 있다 면 최대한 그 벽을 피해가는 방향으로 회전을 하며 벽이 좌우측에 모두 없는 경우(갈림길)는 방위를 통해 나아 갈 목표지점을 찾아가기 위한 flag를 세팅하여주고, 벽이 있다면 그 벽을 피해 가기 위해 flag세팅을 합니다. - 장애물이 앞에 없는 경우(초음파 센서로 바로 앞에 장애물이 탐지되지 않은 경우) 장애물이 앞에 없더라도, ubrain이 움직이는 방위에 따라서, 어느 방향으로 움직일지 계산합니다. 만약 동쪽으로 움직이고 있다면 초음파 센서의 좌측을 탐지하여 좌측에 통로가 생기면 바로 좌측 길을 활용하고, 서쪽으로 움 직이고 있다면 초음파 센서의 우측을 탐지해 우측 통로가 생기면 바로 우측길을 이용합니다. - IR센서로 장애물이 가까움을 감지한 경우(대각선의 장애물이 가까워지는 경우) IR센서로 장애물이 가까워짐을 탐지하면 약간만 회전을 해주어 장애물을 피해가도록 합니다. 그 외의 경우는 모터를 항상 앞으로 갈 수 있도록 FRONT로 설정하여줍니다.   
- 모터 제어 테스크(테스크2)   
모터를 제어하는 테스크는 장애물 탐지 및 방향 설정 테스크에서 세팅된 값을 확인하여 그 설정에 맞추어 움직 임을 제공합니다. Motor를 제어하기 위해서 왼쪽 오른쪽으로 90도 회전하는 것과 약간만 회전하는 함수를 설계 하였습니다. 이 때 90도 회전시에는 방위를 설정하는 역할까지 수행하도록 합니다.   
 ----------------------------------------------------------------------
## 구현 알고리즘
1. 장애물 탐지 및 방향 설정 테스크 알고리즘  
![flow chart](flowchart.PNG)  
초음파 센서를 활용하여 앞에 물체가 있는지 확인합니다.  
- 앞에 물체가 있는 경우   
좌 우측에 벽이 있는지 확인을 합니다.  
(1) 좌 우측에 벽이 모두 없는 경우 방위에 따라 움직일 방향을 정해줍니다. 방위가 동쪽이면 좌측으로 그 외에 경우는 모두 우측으로 설정합니다.    (2) 좌 우측에 벽이 하나 혹은 2개 다 있는 경우 오른쪽에 벽이 있다면, 오른쪽 벽을 피해 왼쪽으로 그 외에 경우 모두 오른쪽으로 설정하여줍니다.      
- 앞에 물체가 없는 경우   
IR센서가 감지하였는지 확인하여 줍니다.   
(1) IR 센서가 감지한 경우 감지된 센서의 반대방향으로 약간의 보정을 해 올바르게 길을 갈 수 있게 설정합니다.   
(2) IR 센서가 감지하지 않은 경우 방위를 보고 만약 방위가 북쪽이나 남쪽이면 계속 직진을 수행합니다. 동쪽이나 서쪽일 경우는 빠르게 나아가기 위하여 계속 좌 우측 초음파 센서 값을 확인합니다.   
■ 동쪽으로 가고 있는 경우   
왼쪽의 초음파 센서값을 읽어서 왼쪽에 길이 생기면 왼쪽으로 바로 이동해 북쪽으로 가도록 합니다.   
■ 서쪽으로 가고 있는 경우  
오른쪽의 초음파 센서값을 읽어서 오른쪽에 길이 생기면 오른쪽으로 바로 이동해 북쪽으로 가도록 합니다. 그 외에 경우에는 계속 직진을 할 수 있도록 합니다.

2. 모터 제어 테스크 알고리즘  
MoveStatus를 확인하여 적절한 움직임을 제공하여주기만 하면 됩니다. 장애물 탐지 및 방향 설정 테스크에서 어떻게 움직여야할지 방향을 제시하면 그에 대한 모터 제어를 수행합니다. 좌측 그리고 우측의 90도 방향 회전 이 이루어질 때, 방위를 변경하여주게 됩니다.   
방위 계산은 북쪽을 0 동쪽을 1 남쪽을 2 서쪽을 3으로 하여 우측 90도 회전시 +1 후 %연산으로 방위 계산을 좌측 90도 회전시 + 3 후 % 연산으로 방위를 계산하도록 하였습니다.  

 ----------------------------------------------------------------------
## 대회 영상 및 성능 분석
1. 1차 주행(성공 - 2등)   
- 주행 영상  
[![1차주행](https://img.youtube.com/vi/eUQFtpxet1k/0.jpg)](https://www.youtube.com/watch?v=eUQFtpxet1k&feature=youtu.be)   
- 성능 분석  
1차 주행시에 가장 불안하였던 성능은, 동쪽 혹은 서쪽으로 이동하는 경우에 북쪽으로 갈 수 있는 길이 있다면 가게 되는데, 그것의 딜레이 값이 조금 길어서 약간 원하는 경로로 가지 못하는 경우가 생기는 문제점이 있었 다. 하지만 IR센서를 활용하여 약간의 보정을 해주는 등의 주행 중 오류를 보정하는 것을 통하여 안정적으로 완 주를 할 수 있게 되었다. 또한 정확하게 Calibration을 수행해 주어 거의 직선으로 이동하였고, 회전도 바퀴가 틈 에 끼지 않는 이상 거의 90도를 회전하는 모습을 보여 굉장히 빠른 시간(59초)에 통과할 수 있었다. 목표하였던 시간 단축을 위해 수행해주었던 작업들이 모두 성공적으로 동작함을 알 수 있었다.  
2. 2차 주행(실패)  
- 주행 영상  
[![2차주행](https://img.youtube.com/vi/WR9yNRtPYPo/0.jpg)](https://www.youtube.com/watch?v=WR9yNRtPYPo&feature=youtu.be)  
- 성능 분석
2차 주행에서는 1차 주행 때 불안하였던 점을 보완하기 위하여 딜레이를 조금 낮추어 진행을 하였다. 시간은 훨 씬 단축되는 효과를 볼 수 있었는데, 마지막에 IR센서가 오작동을 하는 바람에 방향 조정을 하지 않아서 실패하 는 아쉬움이 있었다.  
 ----------------------------------------------------------------------
## 프로젝트 진행 소감
초기에는 RTOS의 API인 세마포어와 인터럽트를 활용하여 협력형으로 개발을 하려고 하였었으나, 다소 어려운 점이 많았습니다. 따라서 저희는 두 개의 테스크를 활용하여 위처럼 개발을 하게 되었습니다. 초기에 많은 생각 을 할 수 있었고, 그 결과 최대한 빨리 목표지점에 도달할 수 있는 알고리즘을 생각해 보자 라는 취지로 생각해 낸 방법이 ubrain이 지금 어느 방향으로 가고 있는지 알고 그 방향을 알면 최대한 빨리 목표지점에 도달할 수 있겠다는 생각을 하였습니다. 가장 힘들었던 것은 바로 Calibration와 ubrain의 원인을 알 수 없는 예측 불가 행동을 제어하는 것입니다. 어떻 게 움직이는지 디버깅을 하는 방법이 너무 어려워서 LED를 활용해 어떻게 움직이는지 확인을 하는 방법을 택하 여 수 백번 이상 코드의 값들을 수정하고 다시 올려서 확인하는 노력을 하였습니다. 그 과정이 상당히 어려웠지 만 주행결과는 2등이라는 만족스러운 점수를 얻게되어 기쁩니다.


--------------------------------------------------------------
## 11.AI(Artificial Intelligence
- 충남대학교 2019년도 가을학기 인공지능    
  
## 과제 
### HW1_Baysian  
- Naive Bayes
- 두개의 클래스의 분포 생성
- prior를 다르게하여, 두개의 분류기 생성 후 결과 분석
   
### HW2
- MLP활용  
- 케라스와 Sklearn 활용해 MLP 모델생성  
- 전복데이터를 활용하여 전복의 성별 분류하는 과제  

### HW3_CNN  
- CNN활용  
- 케라스를 활용하여 CNN학습  
- MNIST데이터를 활용하여 손글씨를 분류하는 과제
  
### Term Project  
- MLP와 Bayesian활용  
- SMOTE, RandomForest, 로지스틱 회귀 등의 방법으로 데이터 분석 진행  
- 작업자데이터를 활용하여 불량품을 사전예측하는 시스템 개발을 위한 머신러닝 분석  
- 데이터는 유라테크의 작업공정(데이터는 삭제)

# CapStorn_Project
- 프로젝트 명 : 작업자 데이터를 활용한 품질 불량 사전 예측 시스템
- 데이터 : 유라테크 베트남 공정데이터(기업 데이터이기 때문에 배포 안함)
- 충남대학교 컴퓨터공학과 학위논문
- 참가 대회 : 2019년도 창의작품 경진대회  
[![창의작품 경진대회](https://img.youtube.com/vi/o6ouqZAxguw/0.jpg)](https://www.youtube.com/watch?v=o6ouqZAxguw) 
## 연구 개요
1. 추진 배경  
머신러닝 기반 품질문제 사전예측에 대한 연구는 활발히 이루어지고 있다. 하지만 화학, 반도체 등의 지능화된 설비를 활용한 제조업 분야에서만 연구 활동이 활발히 이루어져 제조업에만 적용이 가능하다. 작업자에 의존하는 조립산업 적용을 위한 연구는 부족한 상황이다.
1. 문제 정의  
추진배경에서 설명하였던 추진배경의 문제점을 해결하기 위해서, 작업자에 의존하는 조립 산업공정에 적용을 위한 연구의 부족함을 해결하기 위하여 많은 연구가 진행되어야 할 것이다.  
기술적 요인으로 모델을 생성할 때 많은 변수들 중 어느 변수를 사용할 경우 더 좋은 결과를 낼 수 있는지, 과적합을 방지할 수 있을지에 대한 연구가 필요할 것이다.  
그리고, 불균형 데이터를 활용하여 학습을 할 때, 비율이 높은 클래스로 선택을 할 확률이 굉장히 높아, 모델 생성에 큰 제약이 있는데 이를 방지하기 위한 효과적인 해결책을 찾아야 할 것이다.  
1. 목표 및 내용  
공정 및 작업자 데이터를 활용하여 품질 불량을 사전에 예측하는 목표를 달성하기 위한 머신러닝 기반 연구를 하여 효율적인 변수 선택법과 데이터 생성 방법을 찾아내는 것이 목표이다.  
활용 데이터는 공정데이터로 불량품과 양품이 불균형을 이루는 데이터이다. 불균형 데이터를 균형 데이터로 바꾸는 작업과 많은 변수들이 존재할 때, 머신러닝 기반 분석방법으로 효율적으로 변수를 선택하는 작업을 수행할 것이다.
1. 기대효과  
작업자에 의존하는 조립 산업에서 머신러닝을 활용하여 높은 성능을 기대할 수 있다.  
작업자에 대한 많은 변수들 중, 어느 방법으로 학습할 변수를 선택할 때 좋은 결과를 얻을 수 있는지에 대한 방법을 알 수 있다.
--------------------------
## 연구 기획
1. 변수 선택  
RandomForest로 분석을 하여, 변수의 중요도를 계산하고 중요도가 낮은 변수를 삭제하여 변수를 선택하는 방법으로 변수를 선택할 수 있다. 변수의 중요도는 불순도 개선에 얼마나 큰 영향을 끼쳤는지에 대한 여부이다.  
Logistic Regression으로 분석을 하여, p-value를 도출하고 p값이 a = 0.05 이하인 변수는 타겟변수를 찾아내는데 연관성이 있는 변수이므로 해당 변수만을 활용하여 학습을 진행한다.  
위 두 가지 방법을 모두 활용하여 변수를 선택하고 분석을 진행한다.  
1. 불량품 데이터 생성  
Gan을 활용하여 불량품 데이터를 생성할 계획을 조기에 기획하였지만, 생각보다 학습에 많은 어려움을 겪고 좋은 데이터를 생성하지 못하여, Gan을 활용한 데이터 생성 연구는 중단하였다.  
Synthetic Minority Over-sampling Technique을 활용하여 불량품 데이터를 생성하여, 데이터 불균형 문제를 해결한다. SMOTE는 오버샘플링 기법으로 불량품의 데이터 개수를 효과적으로 증가 시킬 수 있는 장점이 있다.  
1. 모델 생성
SMOTE를 활용 전, Naive Bayes의 Prior를 Risk의 역할을 수행하도록 하여, 이를 적절한 값으로 변경해 불량품을 잘 선별해내는 모델을 생성한다.  
SMOTE를 활용 후, Multi Layer Perceptron을 활용하여 불량품을 조기에 예측하는 모델을 생성한다.  
--------------------------------
## 연구 결론
1. p-value와 RandomForest 연구 결과
모든 변수를 활용하여 학습을 하는 경우와 p-value와 RandomForest를 활용하여 변수를 선택을 하게 되면 비슷한 성능을 내거나 혹은 좀 더 좋은 성능을 낼 수 있음을 확인하였다.   
그리고, 데이터의 성질에 따라 어떠한 변수를 쓰는지에 따라 모델이 민감해지는 것이 다양하기 때문에 어떠한 방법을 활용할 때 모델이 더 민감해지는지에 대한 결론을 도출하지 못하였다.  
하지만, 모든 변수를 활용하여 학습을 할 때보다 훨씬 더 적은 변수로 비슷하거나 더 좋은 성능을 낼 수 있는 것을 보면 모델의 capacity를 줄이고자 할 때, 매우 효과적인 방법이라고 제시할 수 있다.  
1. Naive Bayes와 MLP 연구 결과  
결과는 MLP를 활용하는 경우가 좀 더 좋은 성과를 거두었음을 알 수 있다. Naive Bayes는 단순히 Prior를 좀 더 민감하게 주어 불량품을 뽑아내는 것이지만, MLP는 데이터를 직접 학습하여 뽑아내는 것이기 때문에 불량품을 비교적 잘 뽑아낼 수 있었다.   
하지만, MLP를 활용하기 위해서는 불균형 데이터 문제를 해결해야한다. 우리는 SMOTE를 활용하여 해결하였지만, 이 불균형 문제를 더 잘 해결할 수 있다면 더 높은 결과가 도출될 수 있을 것이라고 판단되어진다.  
그리고 MLP를 활용하기 위해서는 그 만큼 많은 데이터가 요구되어짐을 데이터를 점차 줄여나가면서 학습해본 결과 알 수 있다. 
따라서 결론적으로 MLP를 활용하기 위해서 많은 데이터와 좋은 불량품 데이터를 생성할 수 있다면 더 잘 예측하는 모델을 생성 할 수 있음을 알 수 있었다.  





